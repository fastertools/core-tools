use ftl_sdk::{tool, ToolResponse};
use serde::Deserialize;
use schemars::JsonSchema;

// Example: Distance calculation tool using ftl-sdk
#[derive(Deserialize, JsonSchema)]
struct DistanceInput {
    /// Latitude of the first point
    lat1: f64,
    /// Longitude of the first point
    lon1: f64,
    /// Latitude of the second point
    lat2: f64,
    /// Longitude of the second point
    lon2: f64,
}

/// Calculate distance between two GPS coordinates using Haversine formula
#[tool]
fn distance(input: DistanceInput) -> ToolResponse {
    use crate::geospatial::distance::{CoordinateInput, calculate_distance};
    
    let internal_input = CoordinateInput {
        lat1: input.lat1,
        lon1: input.lon1,
        lat2: input.lat2,
        lon2: input.lon2,
    };
    
    let result = calculate_distance(internal_input);
    ToolResponse::text(serde_json::to_string(&result).unwrap())
}

// Bearing calculation tool
#[derive(Deserialize, JsonSchema)]
struct BearingInput {
    /// Latitude of the first point
    lat1: f64,
    /// Longitude of the first point
    lon1: f64,
    /// Latitude of the second point
    lat2: f64,
    /// Longitude of the second point
    lon2: f64,
}

/// Calculate bearing between two GPS coordinates
#[tool]
fn bearing(input: BearingInput) -> ToolResponse {
    use crate::geospatial::bearing::{BearingInput as InternalInput, calculate_bearing};
    
    let internal_input = InternalInput {
        lat1: input.lat1,
        lon1: input.lon1,
        lat2: input.lat2,
        lon2: input.lon2,
    };
    
    match calculate_bearing(internal_input) {
        Ok(result) => ToolResponse::text(serde_json::to_string(&result).unwrap()),
        Err(e) => ToolResponse::text(format!("Error: {}", e.error)),
    }
}

// Descriptive Statistics tool
#[derive(Deserialize, JsonSchema)]
struct DescriptiveStatsInput {
    /// Array of numerical data
    data: Vec<f64>,
}

/// Calculate comprehensive descriptive statistics
#[tool]
fn descriptive_stats(input: DescriptiveStatsInput) -> ToolResponse {
    use crate::statistics::descriptive::{DescriptiveStatsInput as InternalInput, calculate_descriptive_stats};
    
    let internal_input = InternalInput {
        data: input.data,
    };
    
    match calculate_descriptive_stats(internal_input) {
        Ok(result) => ToolResponse::text(serde_json::to_string(&result).unwrap()),
        Err(e) => ToolResponse::text(format!("Error: {}", e.error)),
    }
}